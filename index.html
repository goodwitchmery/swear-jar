<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Swear Jar</title>
  <style>
    body {
      background-color: black;
      color: orange;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      font-size: 2.8em;
      margin-top: 12vh;
      text-shadow: 0 0 15px #ffb000;
    }
    #counter {
      font-size: 8em;
      font-weight: bold;
      text-shadow: 0 0 25px #ff9900;
      margin-top: 10px;
    }
    .button-container {
      margin-top: 40px;
    }
    button {
      background-color: orange;
      color: black;
      font-size: 1.4em;
      font-weight: bold;
      padding: 14px 32px;
      margin: 10px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 0 12px #ff9900;
      transition: 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover {
      background-color: #ffb733;
      box-shadow: 0 0 18px #ffb733;
    }
    button.active {
      background-color: #ffaa00;
    }
    #log {
      margin-top: 40px;
      font-size: 0.9em;
      color: #ccc;
      max-width: 80%;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Swear count</h1>
  <div id="counter">0</div>

  <div class="button-container">
    <button id="listenBtn">üéôÔ∏è Start listening</button>
    <button id="resetBtn">‚ü≥ Reset</button>
  </div>

  <div id="log"></div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const workerURL = "https://swearjar.goodwitchmery.workers.dev";

      const counterEl = document.getElementById("counter");
      const logEl = document.getElementById("log");
      const listenBtn = document.getElementById("listenBtn");
      const resetBtn = document.getElementById("resetBtn");

      let recognizing = false;
      let recognition = null;
      let currentCount = 0;

      // Wszystkie angielskie przekle≈Ñstwa + to co mia≈Ça≈õ wcze≈õniej
      const swearWords = [
        "fuck","fucking","motherfucker","mf","shit","bullshit","bastard","bitch","slut","whore",
        "ass","asshole","arse","arsehole","dick","dickhead","prick","cock","cocksucker",
        "cunt","twat","wanker","bollocks","bloody","damn","crap","jerk","douche","freak",
        "pussy","suck","sucks","sucker","fucker"
      ];

      // ---------- UI / LOGIC ----------

      function log(msg) {
        const ts = new Date().toLocaleTimeString();
        logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
      }

      function setCount(n) {
        const safe = Number.isFinite(n) && n >= 0 ? n : 0;
        currentCount = safe;
        counterEl.textContent = String(safe);
        // cache tylko pomocniczo (np. gdy Worker nie odpowie)
        localStorage.setItem("swearCount_cache", String(safe));
      }

      // Liczenie przekle≈Ñstw w tek≈õcie (wiele + gwiazdki)
      function countSwearsIn(text) {
        if (!text) return 0;
        const lower = text.toLowerCase();
        let delta = 0;

        // s≈Çowa
        for (const w of swearWords) {
          const rx = new RegExp(
            `\\b${w.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&")}\\b`,
            "gi"
          );
          const m = lower.match(rx);
          if (m) delta += m.length;
        }

        // ciƒÖgi gwiazdek typu ****
        const stars = lower.match(/\*{3,}/g);
        if (stars) delta += stars.length;

        return delta;
      }

      // ---------- WORKER: ≈πR√ìD≈ÅO PRAWDY ----------

      async function loadFromWorker() {
        try {
          const r = await fetch(`${workerURL}/count`, { cache: "no-store" });
          if (!r.ok) throw new Error("Worker HTTP " + r.status);
          const j = await r.json();
          const remote = parseInt(j.count, 10);
          if (Number.isFinite(remote) && remote >= 0) {
            setCount(remote);
            log(`Loaded count from Worker: ${remote}`);
          } else {
            setCount(0);
            log("Worker returned invalid count, using 0.");
          }
        } catch (e) {
          console.warn("Worker /count failed:", e);
          const cached = parseInt(
            localStorage.getItem("swearCount_cache") || "0",
            10
          );
          setCount(Number.isFinite(cached) && cached >= 0 ? cached : 0);
          log(
            "Could not reach Worker. Using last cached local value: " +
              currentCount
          );
        }
      }

      async function incrementOnWorker(delta) {
        if (delta <= 0) return;
        try {
          const r = await fetch(`${workerURL}/increment`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ delta })
          });
          if (!r.ok) throw new Error("Worker HTTP " + r.status);
          const j = await r.json();
          const remote = parseInt(j.count, 10);
          if (Number.isFinite(remote) && remote >= 0) {
            setCount(remote);
            log(`Count updated: +${delta} ‚Üí ${remote}`);
          } else {
            throw new Error("Invalid count from Worker");
          }
        } catch (e) {
          console.error("Worker increment failed:", e);
          log("Error talking to Worker. Count may be out of sync.");
        }
      }

      async function resetOnWorker() {
        try {
          const r = await fetch(`${workerURL}/reset`, { method: "POST" });
          if (!r.ok) throw new Error("Worker HTTP " + r.status);
          const j = await r.json();
          const remote = parseInt(j.count, 10);
          if (Number.isFinite(remote) && remote >= 0) {
            setCount(remote);
            log("Counter reset.");
          } else {
            throw new Error("Invalid count from Worker");
          }
        } catch (e) {
          console.error("Worker reset failed:", e);
          log("Could not reset on Worker.");
        }
      }

      // ---------- INIT ----------

      (async function init() {
        listenBtn.textContent = "üéôÔ∏è Start listening";
        log('Click "Start listening" to begin.');
        await loadFromWorker(); // Worker jest ≈∫r√≥d≈Çem prawdy
      })();

      // ---------- SPEECH RECOGNITION ----------

      async function startRecognition() {
        if (recognizing) return;
        try {
          log("Requesting microphone access...");
          await navigator.mediaDevices.getUserMedia({ audio: true });
          log("Microphone access granted.");

          const SR =
            window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SR) {
            log("Speech recognition not supported in this browser.");
            return;
          }

          recognition = new SR();
          recognition.lang = "en-US";
          recognition.continuous = true;
          recognition.interimResults = false;

          recognition.onstart = () => {
            recognizing = true;
            listenBtn.classList.add("active");
            listenBtn.textContent = "‚è∏ Pause";
            log("Listening for English swears...");
          };

          recognition.onerror = (ev) => {
            console.error(ev);
            log(`Recognition error: ${ev.error}`);
            if (
              recognizing &&
              (ev.error === "no-speech" ||
                ev.error === "network" ||
                ev.error === "aborted")
            ) {
              try {
                recognition.stop();
              } catch {}
              try {
                recognition.start();
              } catch (e2) {
                console.error(e2);
                log("Restart failed.");
                recognizing = false;
                listenBtn.classList.remove("active");
                listenBtn.textContent = "üéôÔ∏è Start listening";
              }
            }
          };

          recognition.onend = () => {
            if (recognizing) {
              log("Recognition ended, restarting...");
              try {
                recognition.start();
              } catch (e) {
                console.error(e);
                log("Restart failed.");
                recognizing = false;
                listenBtn.classList.remove("active");
                listenBtn.textContent = "üéôÔ∏è Start listening";
              }
            } else {
              listenBtn.classList.remove("active");
              listenBtn.textContent = "üéôÔ∏è Start listening";
            }
          };

          recognition.onresult = async (ev) => {
            const res = ev.results[ev.results.length - 1][0];
            const text = (res.transcript || "").trim();
            if (!text) return;
            log(`Heard: ${text}`);
            const delta = countSwearsIn(text);
            if (delta > 0) {
              log(`ü§¨ Swear detected! +${delta}`);
              await incrementOnWorker(delta);
            }
          };

          recognition.start();
        } catch (err) {
          console.error(err);
          log(`Start failed: ${err.message || err}`);
          recognizing = false;
          listenBtn.classList.remove("active");
          listenBtn.textContent = "üéôÔ∏è Start listening";
        }
      }

      function stopRecognition() {
        recognizing = false;
        try {
          recognition && recognition.stop();
        } catch {}
        listenBtn.classList.remove("active");
        listenBtn.textContent = "üéôÔ∏è Start listening";
        log("Listening stopped.");
      }

      listenBtn.addEventListener("click", () => {
        recognizing ? stopRecognition() : startRecognition();
      });

      resetBtn.addEventListener("click", () => {
        stopRecognition();
        resetOnWorker();
      });
    });
  </script>
</body>
</html>
