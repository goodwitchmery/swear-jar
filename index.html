<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Swear Jar</title>
  <style>
    body {
      background-color: black;
      color: orange;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    h1 {
      font-size: 2.8em;
      margin-top: 12vh;
      text-shadow: 0 0 15px #ffb000;
    }
    #counter {
      font-size: 8em;
      font-weight: bold;
      text-shadow: 0 0 25px #ff9900;
      margin-top: 10px;
    }
    .button-container {
      margin-top: 40px;
    }
    button {
      background-color: orange;
      color: black;
      font-size: 1.4em;
      font-weight: bold;
      padding: 14px 32px;
      margin: 10px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 0 12px #ff9900;
      transition: 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover {
      background-color: #ffb733;
      box-shadow: 0 0 18px #ffb733;
    }
    button.active {
      background-color: #ffaa00;
    }
    #log {
      margin-top: 40px;
      font-size: 0.9em;
      color: #ccc;
      max-width: 80%;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>Swear count</h1>
  <div id="counter">0</div>

  <div class="button-container">
    <button id="listenBtn">üéôÔ∏è Start listening</button>
    <button id="resetBtn">‚ü≥ Reset</button>
  </div>

  <div id="log"></div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const workerURL = "https://swearjar.goodwitchmery.workers.dev";

      const counterEl = document.getElementById("counter");
      const logEl = document.getElementById("log");
      const listenBtn = document.getElementById("listenBtn");
      const resetBtn = document.getElementById("resetBtn");

      let recognizing = false;
      let recognition = null;
      let currentCount = 0;

      const swearWords = [
        "fuck","fucking","motherfucker","mf","shit","bullshit","bastard","bitch","slut","whore",
        "ass","asshole","arse","arsehole","dick","dickhead","prick","cock","cocksucker",
        "cunt","twat","wanker","bollocks","bloody","damn","crap","jerk","douche","freak",
        "pussy","suck","sucks","sucker","fucker"
      ];

      function log(msg) {
        const ts = new Date().toLocaleTimeString();
        logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
      }

      function setCount(n) {
        const safe = Number.isFinite(n) && n >= 0 ? n : 0;
        currentCount = safe;
        counterEl.textContent = String(safe);
        localStorage.setItem("swearCount", String(safe));
      }

      // Liczenie przekle≈Ñstw w danym tek≈õcie
      function countSwearsIn(text) {
        if (!text) return 0;
        const lower = text.toLowerCase();
        let delta = 0;

        for (const w of swearWords) {
          const rx = new RegExp(
            `\\b${w.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&")}\\b`,
            "gi"
          );
          const m = lower.match(rx);
          if (m) delta += m.length;
        }

        const stars = lower.match(/\*{3,}/g);
        if (stars) delta += stars.length;

        return delta;
      }

      // Inkrementacja: najpierw lokalnie, potem pr√≥bujemy Worker
      async function incrementCount(delta) {
        if (delta <= 0) return;
        const localTarget = currentCount + delta;
        setCount(localTarget);

        try {
          const r = await fetch(`${workerURL}/increment`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ delta })
          });
          if (!r.ok) throw new Error("Worker HTTP " + r.status);
          const j = await r.json();
          if (Number.isFinite(j.count) && j.count >= localTarget) {
            setCount(j.count);
            log(`Synced with Worker: ${j.count}`);
          } else {
            log("Worker responded, keeping local count.");
          }
        } catch (e) {
          console.warn("Worker increment failed:", e);
          log("Worker increment failed, using local only.");
        }
      }

      // Reset: zerujemy lokalnie i pr√≥bujemy wyzerowaƒá Worker
      async function resetCount() {
        setCount(0);
        try {
          const r = await fetch(`${workerURL}/reset`, { method: "POST" });
          if (!r.ok) throw new Error("Worker HTTP " + r.status);
          const j = await r.json();
          if (Number.isFinite(j.count)) {
            setCount(j.count);
          }
          log("Counter reset.");
        } catch (e) {
          console.warn("Worker reset failed:", e);
          log("Worker reset failed, local reset only.");
        }
      }

      // Przy starcie: odczyt lokalny + ewentualna synchronizacja w g√≥rƒô z Workerem
      (async function init() {
        const saved = parseInt(localStorage.getItem("swearCount") || "0", 10);
        if (Number.isFinite(saved) && saved > 0) {
          setCount(saved);
          log(`Loaded saved count: ${saved}`);
        } else {
          setCount(0);
          log("No saved count, starting from 0.");
        }

        log('Click "Start listening" to begin.');

        try {
          const r = await fetch(`${workerURL}/count`, { cache: "no-store" });
          if (!r.ok) throw new Error("Worker HTTP " + r.status);
          const j = await r.json();
          const remote = parseInt(j.count, 10);
          if (Number.isFinite(remote) && remote > currentCount) {
            setCount(remote);
            log(`Synced count from Worker: ${remote}`);
          } else {
            log("Worker count not higher than local, keeping local value.");
          }
        } catch (e) {
          console.warn("Worker /count failed:", e);
          log("Could not sync from Worker, using local value only.");
        }
      })();

      // --- Speech recognition ---

      async function startRecognition() {
        if (recognizing) return;
        try {
          log("Requesting microphone access...");
          await navigator.mediaDevices.getUserMedia({ audio: true });
          log("Microphone access granted.");

          const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SR) {
            log("Speech recognition not supported in this browser.");
            return;
          }

          recognition = new SR();
          recognition.lang = "en-US";
          recognition.continuous = true;
          recognition.interimResults = false;

          recognition.onstart = () => {
            recognizing = true;
            listenBtn.classList.add("active");
            listenBtn.textContent = "‚è∏ Pause";
            log("Listening for English swears...");
          };

          recognition.onerror = (ev) => {
            console.error(ev);
            log(`Recognition error: ${ev.error}`);
            if (
              recognizing &&
              (ev.error === "no-speech" ||
                ev.error === "network" ||
                ev.error === "aborted")
            ) {
              try { recognition.stop(); } catch {}
              try { recognition.start(); } catch (e) {
                console.error(e);
                log("Restart failed.");
              }
            }
          };

          recognition.onend = () => {
            if (recognizing) {
              log("Recognition ended, restarting...");
              try { recognition.start(); } catch (e) {
                console.error(e);
                log("Restart failed.");
                recognizing = false;
                listenBtn.classList.remove("active");
                listenBtn.textContent = "üéôÔ∏è Start listening";
              }
            } else {
              listenBtn.classList.remove("active");
              listenBtn.textContent = "üéôÔ∏è Start listening";
            }
          };

          recognition.onresult = async (ev) => {
            const res = ev.results[ev.results.length - 1][0];
            const text = (res.transcript || "").trim();
            if (!text) return;
            log(`Heard: ${text}`);
            const delta = countSwearsIn(text);
            if (delta > 0) {
              log(`ü§¨ Swear detected! +${delta}`);
              await incrementCount(delta);
            }
          };

          recognition.start();
        } catch (err) {
          console.error(err);
          log(`Start failed: ${err.message || err}`);
          recognizing = false;
          listenBtn.classList.remove("active");
          listenBtn.textContent = "üéôÔ∏è Start listening";
        }
      }

      function stopRecognition() {
        recognizing = false;
        try { recognition && recognition.stop(); } catch {}
        listenBtn.classList.remove("active");
        listenBtn.textContent = "üéôÔ∏è Start listening";
        log("Listening stopped.");
      }

      listenBtn.addEventListener("click", () => {
        recognizing ? stopRecognition() : startRecognition();
      });

      resetBtn.addEventListener("click", () => {
        stopRecognition();
        resetCount();
      });
    });
  </script>
</body>
</html>
