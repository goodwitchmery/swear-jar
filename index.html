<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Swear Jar</title>
  <style>
    body {
      background-color: #000;
      color: #ffa500;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    h1 {
      font-size: 3em;
      margin-top: 10vh;
      text-shadow: 0 0 15px #ffb000;
    }
    #username-label {
      font-size: 1.2em;
      margin-top: 5px;
      color: #ffe0a0;
    }
    #counter {
      font-size: 8em;
      font-weight: bold;
      text-shadow: 0 0 25px #ff9900;
      margin-top: 20px;
    }
    .button-container {
      margin-top: 30px;
    }
    button {
      background-color: #ffa500;
      color: #000;
      font-size: 1.2em;
      font-weight: bold;
      padding: 12px 26px;
      margin: 10px;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      box-shadow: 0 0 12px #ff9900;
      transition: all 0.15s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    button:hover {
      background-color: #ffb733;
      transform: translateY(-1px);
    }
    button.active {
      background-color: #ffcc33;
    }
    #log {
      margin-top: 40px;
      font-size: 0.9em;
      color: #ccc;
      max-width: 80%;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Swear count</h1>
  <div id="username-label"></div>
  <div id="counter">0</div>

  <div class="button-container">
    <button id="listenBtn">üéôÔ∏è Start listening</button>
    <button id="resetBtn">‚ü≥ Reset</button>
  </div>

  <div id="log">Click "Start listening" to begin.</div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const WORKER_URL = "https://swearjar.goodwitchmery.workers.dev";

      const counterEl = document.getElementById("counter");
      const logEl = document.getElementById("log");
      const listenBtn = document.getElementById("listenBtn");
      const resetBtn = document.getElementById("resetBtn");
      const userLabel = document.getElementById("username-label");

      let currentUser = null;
      let currentCount = 0;
      let recognizing = false;
      let recognition = null;

      const swearWords = [
        "fuck","fucking","motherfucker","mf",
        "shit","bullshit","bastard","bitch","slut","whore",
        "ass","asshole","arse","arsehole","dick","dickhead","prick","cock","cocksucker",
        "cunt","twat","wanker","bollocks","bloody","damn","crap","jerk","douche","freak",
        "pussy","suck","sucks","sucker","fucker"
      ];

      /* ---------- UI helpers ---------- */

      function setCount(n) {
        currentCount = Number.isFinite(n) && n >= 0 ? n : 0;
        counterEl.textContent = currentCount;
      }

      function log(msg) {
        const ts = new Date().toLocaleTimeString();
        logEl.textContent = `[${ts}] ${msg}\n` + logEl.textContent;
      }

      function requireUser() {
        // spr√≥buj z localStorage
        let u = localStorage.getItem("swearjarUser");
        if (u && /^[a-z0-9_-]{3,32}$/i.test(u)) {
          u = u.toLowerCase();
          localStorage.setItem("swearjarUser", u);
          return u;
        }

        // pytaj dop√≥ki nie poda sensownego nicku lub nie anuluje
        // (anulowanie = brak dzia≈Çania)
        while (true) {
          const input = prompt(
            "Enter your nickname (3-32 letters/digits/_/-).\nEach nickname has its own swear jar."
          );
          if (input === null) {
            alert("Nickname is required to use the swear jar.");
            continue;
          }
          const cleaned = input.trim().toLowerCase();
          if (/^[a-z0-9_-]{3,32}$/.test(cleaned)) {
            localStorage.setItem("swearjarUser", cleaned);
            return cleaned;
          }
          alert("Invalid nickname. Try again.");
        }
      }

      function updateUserLabel() {
        userLabel.textContent = currentUser
          ? `Current jar: ${currentUser}`
          : "";
      }

      /* ---------- Worker API ---------- */

      async function fetchCountFromWorker() {
        if (!currentUser) return;
        try {
          const r = await fetch(
            `${WORKER_URL}/count?user=${encodeURIComponent(currentUser)}`,
            { cache: "no-store" }
          );
          const j = await r.json();
          if (typeof j.count === "number") {
            setCount(j.count);
            log(`Synced count from Worker: ${j.count}`);
          } else {
            setCount(0);
            log("No count yet for this user. Starting from 0.");
          }
        } catch (e) {
          console.error(e);
          log("Could not load count from Worker.");
        }
      }

      async function incrementOnWorker(delta) {
        if (!currentUser || delta <= 0) return;
        try {
          const r = await fetch(`${WORKER_URL}/increment`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ user: currentUser, delta }),
          });
          const j = await r.json();
          if (typeof j.count === "number") {
            setCount(j.count);
          } else {
            setCount(currentCount + delta);
          }
        } catch (e) {
          console.error(e);
          setCount(currentCount + delta); // awaryjnie lokalnie
          log("Error incrementing on Worker (using local value).");
        }
      }

      async function resetOnWorker() {
        if (!currentUser) return;
        try {
          const r = await fetch(`${WORKER_URL}/reset`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ user: currentUser }),
          });
          const j = await r.json();
          setCount(typeof j.count === "number" ? j.count : 0);
          log("Counter reset.");
        } catch (e) {
          console.error(e);
          setCount(0);
          log("Error resetting on Worker (reset locally).");
        }
      }

      /* ---------- Swear detection ---------- */

      function countSwearsIn(text) {
        let delta = 0;
        const lower = text.toLowerCase();

        for (const w of swearWords) {
          const rx = new RegExp(
            `\\b${w.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`,
            "gi"
          );
          const matches = lower.match(rx);
          if (matches) delta += matches.length;
        }

        const stars = lower.match(/\*{3,}/g);
        if (stars) delta += stars.length;

        return delta;
      }

      async function startRecognition() {
        try {
          if (!("webkitSpeechRecognition" in window || "SpeechRecognition" in window)) {
            log("Speech recognition is not supported in this browser.");
            return;
          }

          log("Requesting microphone access...");
          await navigator.mediaDevices.getUserMedia({ audio: true });
          log("Microphone access granted.");

          const SR =
            window.SpeechRecognition || window.webkitSpeechRecognition;
          recognition = new SR();
          recognition.lang = "en-US";
          recognition.continuous = true;
          recognition.interimResults = false;

          recognition.onstart = () => {
            log("üéß Listening for English swears...");
          };

          recognition.onerror = (ev) => {
            console.error(ev);
            log(`Recognition error: ${ev.error}`);
            if (
              recognizing &&
              (ev.error === "no-speech" ||
                ev.error === "network" ||
                ev.error === "aborted")
            ) {
              try {
                recognition.stop();
                recognition.start();
              } catch (_) {}
            }
          };

          recognition.onend = () => {
            if (recognizing) {
              log("Recognition ended, restarting‚Ä¶");
              try {
                recognition.start();
              } catch (e) {
                console.error(e);
                log("Restart failed.");
              }
            }
          };

          recognition.onresult = async (ev) => {
            const res = ev.results[ev.results.length - 1][0];
            const text = (res.transcript || "").trim();
            if (!text) return;
            log(`Heard: ${text}`);
            const delta = countSwearsIn(text);
            if (delta > 0) {
              log(`ü§¨ Swear detected! +${delta}`);
              await incrementOnWorker(delta);
            }
          };

          recognition.start();
          recognizing = true;
          listenBtn.classList.add("active");
          listenBtn.textContent = "‚è∏Ô∏è Pause";
        } catch (err) {
          console.error(err);
          log(`Start failed: ${err.message || err}`);
        }
      }

      function stopRecognition() {
        recognizing = false;
        try {
          recognition && recognition.stop();
        } catch (_) {}
        listenBtn.classList.remove("active");
        listenBtn.textContent = "üéôÔ∏è Start listening";
        log("Listening stopped.");
      }

      /* ---------- Buttons ---------- */

      listenBtn.addEventListener("click", () => {
        if (!currentUser) {
          log("Set a nickname first.");
          return;
        }
        recognizing ? stopRecognition() : startRecognition();
      });

      resetBtn.addEventListener("click", () => {
        if (!currentUser) return;
        resetOnWorker();
      });

      /* ---------- Init ---------- */

      currentUser = requireUser();
      updateUserLabel();
      setCount(0);
      log("Click 'Start listening' to begin.");
      fetchCountFromWorker();
    });
  </script>
</body>
</html>
