<script>
const workerURL = "https://swearjar.goodwitchmery.workers.dev";

const counterDisplay = document.getElementById("counter");
const log = document.getElementById("log");
const listenBtn = document.getElementById("listenBtn");
const resetBtn = document.getElementById("resetBtn");

let recognizing = false;
let recognition;
let swearCount = 0;

// lista przekle≈Ñstw (rozszerzona)
const swearWords = [
  "fuck","shit","bitch","asshole","bastard","dick","pussy","slut","fucker",
  "cock","cunt","bollocks","wanker","motherfucker","prick","damn","crap",
  "bullshit","arse","retard","jerk","douche","freak","bloody","twat",
  "dickhead","whore","fucking"
];

// üî∏ uruchomienie rozpoznawania mowy
function startRecognition() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    logMessage("Speech recognition not supported üò¢");
    return;
  }

  recognition = new SpeechRecognition();
  recognition.lang = "en-US";
  recognition.continuous = true;
  recognition.interimResults = false;

  recognition.onstart = () => logMessage("üéôÔ∏è Listening for English swears...");
  recognition.onend = () => {
    if (recognizing) {
      logMessage("Restarting recognition...");
      recognition.start();
    }
  };

  recognition.onerror = (e) => {
    logMessage(`Error: ${e.error}`);
    if (e.error === "no-speech") recognition.start();
  };

  recognition.onresult = async (event) => {
    const transcript = event.results[event.results.length - 1][0].transcript.toLowerCase().trim();
    logMessage(`Heard: ${transcript}`);

    const delta = countSwears(transcript);
    if (delta > 0) {
      logMessage(`ü§¨ Swear detected! +${delta}`);
      await incrementCount(delta);
    }
  };

  recognition.start();
  recognizing = true;
  listenBtn.textContent = "‚è∏Ô∏è Pause";
  listenBtn.classList.add("active");
}

function stopRecognition() {
  recognizing = false;
  if (recognition) recognition.stop();
  listenBtn.textContent = "üéôÔ∏è Listening...";
  listenBtn.classList.remove("active");
  logMessage("Listening stopped.");
}

function countSwears(text) {
  let count = 0;
  for (const word of swearWords) {
    const regex = new RegExp(`\\b${word}\\b`, "gi");
    const matches = text.match(regex);
    if (matches) count += matches.length;
  }
  // Licz te≈º gwiazdki typu "****"
  const censoredMatches = text.match(/\*{3,}/g);
  if (censoredMatches) count += censoredMatches.length;
  return count;
}

// üî∏ Logi
function logMessage(msg) {
  const now = new Date().toLocaleTimeString();
  log.innerHTML = `[${now}] ${msg}<br>` + log.innerHTML;
}

// üî∏ Worker API
async function updateCountDisplay() {
  try {
    const res = await fetch(workerURL + "/count");
    const data = await res.json();
    swearCount = data.count ?? 0;
    counterDisplay.textContent = swearCount;
  } catch (err) {
    console.error("Error loading count:", err);
  }
}

async function incrementCount(delta) {
  try {
    const res = await fetch(workerURL + "/increment", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ delta })
    });
    const data = await res.json();
    swearCount = data.count ?? swearCount;
    counterDisplay.textContent = swearCount;
  } catch (err) {
    console.error("Increment error:", err);
  }
}

async function resetCount() {
  try {
    const res = await fetch(workerURL + "/reset", { method: "POST" });
    const data = await res.json();
    swearCount = data.count ?? 0;
    counterDisplay.textContent = swearCount;
    logMessage("Counter reset.");
  } catch (err) {
    console.error("Reset error:", err);
  }
}

// üî∏ przyciski
listenBtn.addEventListener("click", () => {
  if (recognizing) stopRecognition();
  else startRecognition();
});

resetBtn.addEventListener("click", resetCount);

// üî∏ start
updateCountDisplay();
</script>
